# Пирамидальная сортировка (Сортировка кучей)

В основе этой сортировки лежит представление массива в виде бинарного сортирующего дерева и сортировка будет происходит непосредственно дерева.

Эффективность - O(n * log n)

Представим у нас есть массив - [2, 5, 7, 132, -9, 0, 4, 6, 11, 11, 22, 5, -3]

Из итого массива получается дерево:

                              2(0)
                            /      \
                        5(1)         7{2}
                     /     \          /   \
               132(3)     -9(4)     0(5)   4(6)
             /    \        /   \    /    \  
         6(7)   11(8) 11(9) 22(10) 5(11) -3(12)


Создание веток для каждого элемента получается по некоторой закономерности:

Для элемента левый потомок будет (индекс * 2 + 1)
Правый потомок будет (индекс * 2 + 2)

То есть для элемента с индексом 3, левый потомок будет с индексом 3 * 2 + 1 = 7, а правый с индексом 3 * 2 + 2 = 8

В дальнейшем это дерево приводится к нормальному виду, то есть левый потомок не больше правого и оба они не меньше родителя и соотвественно получается отсортированный по возрастанию массив.

Пример сортировки по возрастанию - [тут](https://github.com/hardpsycho/algrorithms/blob/master/sort/heapSort/heapSort.ts)

Если нужно отсортировать по убыванию, то следуем обратной логике, что родитель не меньше потомков. Правый потомок не меньше левого.

Проигрывает многим другим сортировкам с эффективность n * log n, но расходует константу памяти и сортирует массив на месте.

